# Supabase Schema and RLS for Jaib Application

This document outlines the PostgreSQL schema and Row Level Security (RLS) policies implemented in Supabase for the Jaib application. The schema is designed to support storing user-saved articles, tagging, and annotations.

## General Principles

- **UUIDs for Primary Keys**: All primary keys (`id` columns) use `UUID` generated by `gen_random_uuid()` for globally unique identifiers.
- **User Scoping**: All data is scoped to the authenticated user. RLS policies ensure users can only access and manage their own data. `(select auth.uid())` is used in RLS policies to refer to the ID of the currently authenticated user.
- **Cascade Deletes**: Foreign key constraints generally use `ON DELETE CASCADE` to maintain data integrity. For example, if a user is deleted, their articles, tags, and annotations are also deleted. If an article is deleted, its associated tags and annotations are also removed.

## Table Schemas and RLS Policies

### 1. `public.articles`

Stores the articles saved by users. Each row represents a unique article saved by a specific user.

**Purpose**: To hold the main content and metadata of articles that users have saved.

**Columns**:

| Column Name         | Data Type                 | Constraints/Defaults                       | Description                                                                        |
| ------------------- | ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------- |
| `id`                | `UUID`                    | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` | Unique identifier for the saved article instance.                                  |
| `user_id`           | `UUID`                    | `NOT NULL`, `FK -> auth.users(id)`         | The user who saved this article.                                                   |
| `title`             | `TEXT`                    | `NOT NULL`                                 | Title of the article.                                                              |
| `content`           | `TEXT`                    | `NOT NULL`                                 | Full HTML content of the article (parsed).                                         |
| `url`               | `TEXT`                    | `NOT NULL`                                 | Original URL of the article.                                                       |
| `excerpt`           | `TEXT`                    |                                            | A short summary or excerpt of the article.                                         |
| `byline`            | `TEXT`                    |                                            | Author or byline of the article.                                                   |
| `length`            | `INTEGER`                 |                                            | Estimated length of the article (e.g., word count or reading time in minutes).     |
| `saved_at`          | `TIMESTAMPTZ`             | `NOT NULL`, `DEFAULT now()`                | Timestamp of when the article was saved.                                           |
| `is_favorite`       | `BOOLEAN`                 | `NOT NULL`, `DEFAULT FALSE`                | Indicates if the user has marked the article as a favorite.                        |
| `is_read`           | `BOOLEAN`                 | `DEFAULT FALSE`                            | Indicates if the user has marked the article as read (archived).                   |
| `lead_image_url`    | `TEXT`                    |                                            | URL of the lead image for the article.                                             |
| `site_name`         | `TEXT`                    |                                            | Name of the website or source of the article.                                      |
| `raw_content_error` | `BOOLEAN`                 | `DEFAULT FALSE`                            | Flag to indicate if there was an error fetching/parsing the raw content initially. |
| _Constraint_        | `unique_user_article_url` | `UNIQUE (user_id, url)`                    | Ensures a user cannot save the same article URL multiple times.                    |

**RLS Policies**:

- Enabled.
- **"Users can select their own articles"**: Allows users to `SELECT` only their own articles.
- **"Users can insert their own articles"**: Allows users to `INSERT` articles, automatically setting `user_id` to their `auth.uid()`.
- **"Users can update their own articles"**: Allows users to `UPDATE` only their own articles.
- **"Users can delete their own articles"**: Allows users to `DELETE` only their own articles.

---

### 2. `public.tags`

Stores tags created by users for categorizing articles.

**Purpose**: To allow users to create and manage a personal set of tags.

**Columns**:

| Column Name  | Data Type              | Constraints/Defaults                       | Description                                               |
| ------------ | ---------------------- | ------------------------------------------ | --------------------------------------------------------- |
| `id`         | `UUID`                 | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` | Unique identifier for the tag.                            |
| `user_id`    | `UUID`                 | `NOT NULL`, `FK -> auth.users(id)`         | The user who created this tag.                            |
| `name`       | `TEXT`                 | `NOT NULL`                                 | The name of the tag (e.g., "Technology", "Productivity"). |
| `created_at` | `TIMESTAMPTZ`          | `NOT NULL`, `DEFAULT now()`                | Timestamp of when the tag was created.                    |
| _Constraint_ | `unique_user_tag_name` | `UNIQUE (user_id, name)`                   | Ensures a tag name is unique for a given user.            |

**RLS Policies**:

- Enabled.
- **"Users can select their own tags"**: Allows `SELECT` of own tags.
- **"Users can insert their own tags"**: Allows `INSERT` of tags for oneself.
- **"Users can update their own tags"**: Allows `UPDATE` of own tags (e.g., renaming).
- **"Users can delete their own tags"**: Allows `DELETE` of own tags.

---

### 3. `public.article_tags`

A join table to create a many-to-many relationship between articles and tags.

**Purpose**: To link specific articles with specific tags, as defined by the user.

**Columns**:

| Column Name   | Data Type         | Constraints/Defaults                        | Description                                                                |
| ------------- | ----------------- | ------------------------------------------- | -------------------------------------------------------------------------- |
| `article_id`  | `UUID`            | `NOT NULL`, `FK -> public.articles(id)`     | Foreign key referencing the article being tagged.                          |
| `tag_id`      | `UUID`            | `NOT NULL`, `FK -> public.tags(id)`         | Foreign key referencing the tag being applied.                             |
| `user_id`     | `UUID`            | `NOT NULL`, `FK -> auth.users(id)`          | The user who made this article-tag association.                            |
| `assigned_at` | `TIMESTAMPTZ`     | `NOT NULL`, `DEFAULT now()`                 | Timestamp of when the tag was assigned to the article.                     |
| _Constraint_  | `pk_article_tags` | `PRIMARY KEY (user_id, article_id, tag_id)` | Ensures a tag is not applied multiple times to the same article by a user. |

**RLS Policies**:

- Enabled.
- **"Users can select their own article-tag links"**: Allows `SELECT` of own article-tag associations.
- **"Users can insert their own article-tag links"**: Allows `INSERT` of links, checking that the user owns both the article and the tag being linked.
- **"Users can delete their own article-tag links"**: Allows `DELETE` of own article-tag associations.

---

### 4. `public.annotations`

Stores user-specific highlights and notes on articles.

**Purpose**: To allow users to select portions of article text, highlight them, and optionally add a note.

**Columns**:

| Column Name     | Data Type     | Constraints/Defaults                       | Description                                                                                                    |
| --------------- | ------------- | ------------------------------------------ | -------------------------------------------------------------------------------------------------------------- |
| `id`            | `UUID`        | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` | Unique identifier for the annotation.                                                                          |
| `article_id`    | `UUID`        | `NOT NULL`, `FK -> public.articles(id)`    | Foreign key referencing the article that is annotated.                                                         |
| `user_id`       | `UUID`        | `NOT NULL`, `FK -> auth.users(id)`         | The user who created this annotation.                                                                          |
| `selector_info` | `JSONB`       | `NOT NULL`                                 | JSONB object storing data to precisely locate the annotation (e.g., text quote, start/end offsets, selectors). |
| `note`          | `TEXT`        |                                            | An optional textual note or comment accompanying the highlight.                                                |
| `created_at`    | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`                | Timestamp of when the annotation was created.                                                                  |
| `updated_at`    | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`                | Timestamp of when the annotation was last updated.                                                             |

**RLS Policies**:

- Enabled.
- **"Users can select their own annotations"**: Allows `SELECT` of own annotations.
- **"Users can insert their own annotations"**: Allows `INSERT` of annotations, checking that the user owns the article being annotated.
- **"Users can update their own annotations"**: Allows `UPDATE` of own annotations (e.g., editing the note).
- **"Users can delete their own annotations"**: Allows `DELETE` of own annotations.

## Relationships Summary

- A `user` (from `auth.users`) can have many `articles`.
- A `user` can create many `tags`.
- An `article` can have many `tags` applied to it by its `user_id` owner, and a `tag` can be applied to many `articles` owned by its `user_id` owner. This many-to-many relationship is managed through the `article_tags` join table.
- An `article` can have many `annotations` made by its `user_id` owner.

This schema provides a robust foundation for the core features of the Jaib application.

I have an edge function in supabase, using the supabase dashboard (you will not see it here in the root directory, and that's by design. I'll paste its code below:

// Follow this setup guide to integrate the Deno language server with your editor:
// https://deno.land/manual/getting_started/setup_your_environment
// This enables autocomplete, go to definition, etc.
// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { Readability } from "npm:@mozilla/readability";
import { DOMParser } from "npm:linkedom";
// Helper function to set CORS headers
const corsHeaders = {
"Access-Control-Allow-Origin": "_",
"Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
"Access-Control-Allow-Methods": "POST, OPTIONS"
};
console.log("fetch-article-data function initializing (v3 with Readability & enhanced image extraction)");
Deno.serve(async (req)=>{
console.log("Request received:", req.method, req.url);
if (req.method === "OPTIONS") {
console.log("Handling OPTIONS request");
return new Response("ok", {
headers: corsHeaders
});
}
try {
let articleUrl;
try {
const body = await req.json();
articleUrl = body.url;
} catch (jsonError) {
console.error("Failed to parse request body as JSON:", jsonError);
return new Response(JSON.stringify({
error: "Invalid JSON payload. Ensure 'url' is provided."
}), {
status: 400,
headers: {
...corsHeaders,
"Content-Type": "application/json"
}
});
}
console.log("Attempting to parse URL:", articleUrl);
if (!articleUrl) {
console.error("No URL provided in request body");
return new Response(JSON.stringify({
error: "No URL provided"
}), {
status: 400,
headers: {
...corsHeaders,
"Content-Type": "application/json"
}
});
}
try {
new URL(articleUrl); // Validate URL
} catch (urlError) {
console.error("Invalid URL format for:", articleUrl, "Error:", urlError);
return new Response(JSON.stringify({
error: "Invalid URL format"
}), {
status: 400,
headers: {
...corsHeaders,
"Content-Type": "application/json"
}
});
}
console.log(`Fetching URL: ${articleUrl}`);
const response = await fetch(articleUrl, {
headers: {
"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,_/\*;q=0.8" // More comprehensive accept header
}
});
if (!response.ok) {
console.error(`Failed to fetch URL: ${articleUrl}, status: ${response.status} ${response.statusText}`);
let responseBodyText = "Could not read response body";
try {
responseBodyText = await response.text();
} catch (e) {}
throw new Error(`HTTP error! status: ${response.status} ${response.statusText}. Response: ${responseBodyText.substring(0, 200)}`);
}
const html = await response.text();
console.log(`HTML received, length: ${html.length}. Parsing with DOMParser...`);
// Use a type assertion for the document object that Readability expects
const doc = new DOMParser().parseFromString(html, "text/html");
if (!doc) {
console.error("Failed to parse HTML document from URL:", articleUrl);
throw new Error("Failed to parse HTML document");
}
let preferredImageUrl = null;
// Step 1: Try common meta tags from the original document
const metaSelectors = [
'meta[property="og:image"]',
'meta[name="twitter:image"]',
'meta[itemprop="image"]'
];
for (const selector of metaSelectors){
const metaTag = doc.querySelector(selector);
if (metaTag && metaTag.getAttribute("content")) {
const imageUrl = metaTag.getAttribute("content").trim();
if (imageUrl) {
try {
preferredImageUrl = new URL(imageUrl, articleUrl).href;
console.log(`Found image via ${selector}:`, preferredImageUrl);
break; // Found an image, no need to check other meta tags
} catch (e) {
console.warn(`Could not construct absolute URL for ${selector} content:`, imageUrl, e.message);
}
}
}
}
console.log("DOM parsed. Applying Readability...");
const reader = new Readability(doc, {});
const article = reader.parse();
if (!article) {
console.error("Failed to parse article with Readability from URL:", articleUrl);
throw new Error("Failed to parse article with Readability");
}
console.log("Article parsed successfully with Readability:", article.title);
// Step 2: If no image from meta tags, try to extract from Readability's article.content
if (!preferredImageUrl && article.content) {
console.log("No meta image found, trying to extract from Readability's HTML content.");
try {
// Parse Readability's cleaned HTML content to find an image
const readabilityDoc = new DOMParser().parseFromString(article.content, "text/html");
const firstImageInContent = readabilityDoc.querySelector('img');
if (firstImageInContent) {
const imgSrcAttr = firstImageInContent.getAttribute('src');
if (imgSrcAttr) {
const imgSrc = imgSrcAttr.trim();
if (imgSrc && !imgSrc.startsWith("data:")) {
try {
preferredImageUrl = new URL(imgSrc, articleUrl).href;
console.log("Found and resolved image from Readability content:", preferredImageUrl);
} catch (e) {
if (imgSrc.startsWith("http://") || imgSrc.startsWith("https://")) {
preferredImageUrl = imgSrc;
console.log("Used image src directly from Readability content (resolution failed or deemed absolute):", preferredImageUrl);
} else {
console.warn("Could not resolve image src from Readability content:", imgSrc, "against base:", articleUrl, "Error:", e.message);
}
}
} else if (imgSrc && imgSrc.startsWith("data:")) {
console.log("Found data URI image in Readability content, skipping for now.");
}
} else {
console.log("First image in Readability content has no src attribute.");
}
} else {
console.log("No img tags found in Readability content.");
}
} catch (e) {
console.warn("Error parsing Readability content for images:", e.message);
}
} else if (preferredImageUrl) {
console.log("Using image from meta tags:", preferredImageUrl);
} else {
console.log("No image found from meta tags, and no Readability content (or image in it).");
}
const data = {
title: article.title || "Untitled",
content: article.content,
textContent: article.textContent,
excerpt: article.excerpt,
byline: article.byline,
length: article.length,
url: articleUrl,
lead_image_url: preferredImageUrl,
};
console.log("Final response data:", data);
return new Response(JSON.stringify(data), {
headers: {
...corsHeaders,
"Content-Type": "application/json"
},
status: 200
});
} catch (error) {
console.error("Error in Edge Function:", error.message, error.stack);
const errorMessage = error instanceof Error ? error.message : String(error);
return new Response(JSON.stringify({
error: "Failed to process article: " + errorMessage
}), {
status: 500,
headers: {
...corsHeaders,
"Content-Type": "application/json"
}
});
}
});
